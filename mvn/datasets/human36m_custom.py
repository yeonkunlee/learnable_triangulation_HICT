import os
from collections import defaultdict
import pickle

import numpy as np
import cv2

import torch
from torch.utils.data import Dataset

from mvn.utils.multiview import Camera
from mvn.utils.img import get_square_bbox, resize_image, crop_image, normalize_image, scale_bbox
from mvn.utils import volumetric

import copy


class Human36MMultiViewDataset_CUSTOM(Dataset):
    """
        Human3.6M for multiview tasks.
    """
    def __init__(self,
                 h36m_root='/datasets/Human3.6M_LT/processed/',
                 labels_path='/datasets/Human3.6M_LT/extra/human36m-multiview-labels-SSDbboxes.npy',
                 pred_results_path=None,
                 image_shape=(384, 384),
                 train=False,
                 test=False,
                 retain_every_n_frames_in_test=1,
                 with_damaged_actions=False,
                 cuboid_side=2000.0,
                 scale_bbox=1.5,
                 norm_image=True,
                 kind="mpii",
                 undistort_images=True,
                 ignore_cameras=[],
                 crop=True,
                 target_subject = None,
                 target_action = None,
                 is_extended = False,
                 option_384x288=False
                 ):
        """
            h36m_root:
                Path to 'processed/' directory in Human3.6M
            labels_path:
                Path to 'human36m-multiview-labels.npy' generated by 'generate-labels-npy-multiview.py'
                from https://github.sec.samsung.net/RRU8-VIOLET/human36m-preprocessing
            retain_every_n_frames_in_test:
                By default, there are 159 181 frames in training set and 26 634 in test (val) set.
                With this parameter, test set frames will be evenly skipped frames so that the
                test set size is `26634 // retain_every_n_frames_test`.
                Use a value of 13 to get 2049 frames in test set.
            with_damaged_actions:
                If `True`, will include 'S9/[Greeting-2,SittingDown-2,Waiting-1]' in test set.
            kind:
                Keypoint format, 'mpii' or 'human36m'
            ignore_cameras:
                A list with indices of cameras to exclude (0 to 3 inclusive)
        """
        assert train or test, '`Human36MMultiViewDataset` must be constructed with at least ' \
                              'one of `test=True` / `train=True`'
        assert kind in ("mpii", "human36m")

        self.h36m_root = h36m_root
        self.labels_path = labels_path
        self.image_shape = None if image_shape is None else tuple(image_shape)
        self.scale_bbox = scale_bbox
        self.norm_image = norm_image
        self.cuboid_side = cuboid_side
        self.kind = kind
        self.undistort_images = undistort_images
        self.ignore_cameras = ignore_cameras
        self.crop = crop
        self.target_subject = target_subject
        self.target_action = target_action
        self.is_extended = is_extended
        self.option_384x288 = option_384x288


        self.labels = np.load(labels_path, allow_pickle=True).item()

        n_cameras = len(self.labels['camera_names'])
        assert all(camera_idx in range(n_cameras) for camera_idx in self.ignore_cameras)

#         train_subjects = ['S1', 'S5', 'S6', 'S7', 'S8']
#         test_subjects = ['S9', 'S11']
        
        train_subjects = []
        #test_subjects = ['S9', 'S11']
        test_subjects = [self.target_subject]

        train_subjects = list(self.labels['subject_names'].index(x) for x in train_subjects)
        test_subjects  = list(self.labels['subject_names'].index(x) for x in test_subjects)

        indices = []
        if train:
            mask = np.isin(self.labels['table']['subject_idx'], train_subjects, assume_unique=True)
            indices.append(np.nonzero(mask)[0])
        if test:
            mask = np.isin(self.labels['table']['subject_idx'], test_subjects, assume_unique=True)
            '''
            if not with_damaged_actions:
                mask_S9 = self.labels['table']['subject_idx'] == self.labels['subject_names'].index('S9')

                damaged_actions = 'Greeting-2', 'SittingDown-2', 'Waiting-1'
                damaged_actions = [self.labels['action_names'].index(x) for x in damaged_actions]
                mask_damaged_actions = np.isin(self.labels['table']['action_idx'], damaged_actions)

                mask &= ~(mask_S9 & mask_damaged_actions)
            '''
            
            mask_subject = self.labels['table']['subject_idx'] == self.labels['subject_names'].index(self.target_subject)
            target_actions = [self.target_action]
            target_actions = [self.labels['action_names'].index(x) for x in target_actions]
            mask_target_actions = np.isin(self.labels['table']['action_idx'], target_actions)
            
            mask = (mask_target_actions & mask_subject)

            indices.append(np.nonzero(mask)[0][::retain_every_n_frames_in_test])

        self.labels['table'] = self.labels['table'][np.concatenate(indices)]

        self.num_keypoints = 16 if kind == "mpii" else 17
        assert self.labels['table']['keypoints'].shape[1] == 17, "Use a newer 'labels' file"
        if is_extended:
            self.num_extended_keypoints = 25
            assert self.labels['table']['keypoints_extended'].shape[1] == 25, "Extended 25 joint label needed."
        
        self.keypoints_3d_pred = None
        if pred_results_path is not None:
            pred_results = np.load(pred_results_path, allow_pickle=True)
            keypoints_3d_pred = pred_results['keypoints_3d'][np.argsort(pred_results['indexes'])]
            self.keypoints_3d_pred = keypoints_3d_pred[::retain_every_n_frames_in_test]
            assert len(self.keypoints_3d_pred) == len(self), \
                f"[train={train}, test={test}] {labels_path} has {len(self)} samples, but '{pred_results_path}' " + \
                f"has {len(self.keypoints_3d_pred)}. Did you follow all preprocessing instructions carefully?"

    def __len__(self):
        return len(self.labels['table'])
    
    def convert_bbox_384x288(self, bbox, p_2D):
        #shot['bbox_by_camera_tlbr'][camera_idx]
        bbox = bbox.astype(float)
        center = [int((bbox[0]+bbox[2])/2), int((bbox[1]+bbox[3])/2)]
        area = abs((bbox[2]-bbox[0])*(bbox[3]-bbox[1]))
        height = np.sqrt(area * (4/3))
        width = (3/4) * height

        x_max = np.max(p_2D[:,0])
        x_min = np.min(p_2D[:,0])
        y_max = np.max(p_2D[:,1])
        y_min = np.min(p_2D[:,1])

        marginal_witdh = max(x_max-center[1], center[1]-x_min)*2
        marginal_height = max(y_max-center[0], center[0]-y_min)*2

        if marginal_witdh > width:
            width = marginal_witdh
            height *= marginal_witdh/width

        if marginal_height > height: # this will be not happened
            height = marginal_height
            width *= marginal_height/height


        bbox = [center[1]-int(width/2), center[0]-int(height/2), center[1]+int(width/2), center[0]+int(height/2)]

        return bbox

    def __getitem__(self, idx):
        sample = defaultdict(list) # return value
        shot = self.labels['table'][idx]

        subject = self.labels['subject_names'][shot['subject_idx']]
        action = self.labels['action_names'][shot['action_idx']]
        frame_idx = shot['frame_idx']

        for camera_idx, camera_name in enumerate(self.labels['camera_names']):
            if camera_idx in self.ignore_cameras:
                continue

            # load camera
            shot_camera = self.labels['cameras'][shot['subject_idx'], camera_idx]
            retval_camera = Camera(shot_camera['R'], shot_camera['t'], shot_camera['K'], shot_camera['dist'], camera_name)
            projection_M = retval_camera.projection # 3,4
            
            # projected_2D
            D3_keypoints_homo = np.pad(shot['keypoints'],((0,0), (0,1)), 'constant', constant_values=1.0) # 17, 4
            projected_2D = np.matmul(projection_M, D3_keypoints_homo.transpose()).transpose()
            projected_2D /= projected_2D[:,2:3]
                
            # load bounding box
            bbox = shot['bbox_by_camera_tlbr'][camera_idx][[1,0,3,2]] # TLBR to LTRB
            
            if self.option_384x288:
                # rewrite bbox
                bbox = self.convert_bbox_384x288(shot['bbox_by_camera_tlbr'][camera_idx], projected_2D) #LTRB
            
            bbox_height = bbox[2] - bbox[0]
            if bbox_height == 0:
                # convention: if the bbox is empty, then this view is missing
                continue

            # scale the bounding box
            bbox = scale_bbox(bbox, self.scale_bbox)

            # load image
            image_path = os.path.join(
                self.h36m_root, subject, action, 'imageSequence' + '-undistorted' * self.undistort_images,
                camera_name, 'img_%06d.jpg' % (frame_idx+1))
            assert os.path.isfile(image_path), '%s doesn\'t exist' % image_path
            image = cv2.imread(image_path)
            
            original_image = image
            
            original_image = cv2.resize(original_image, dsize=(1000,1000))
            sample['original_image'].append(original_image)

#             # load camera
#             shot_camera = self.labels['cameras'][shot['subject_idx'], camera_idx]
#             retval_camera = Camera(shot_camera['R'], shot_camera['t'], shot_camera['K'], shot_camera['dist'], camera_name)

            originla_camera = copy.deepcopy(retval_camera)
            sample['original_cameras'].append(originla_camera)
            
            if self.crop:
                # crop image
                image = crop_image(image, bbox)
                retval_camera.update_after_crop(bbox)

            if self.image_shape is not None:
                # resize
                image_shape_before_resize = image.shape[:2]
                image = resize_image(image, self.image_shape)
                retval_camera.update_after_resize(image_shape_before_resize, self.image_shape)
                sample['image_shapes_before_resize'].append(image_shape_before_resize)

            if self.norm_image:
                image = normalize_image(image)

            sample['images'].append(image)
            sample['detections'].append(bbox + (1.0,)) # TODO add real confidences
            sample['cameras'].append(retval_camera)
            sample['proj_matrices'].append(retval_camera.projection)

        # 3D keypoints
        # add dummy confidences
        sample['keypoints_3d'] = np.pad(
            shot['keypoints'][:self.num_keypoints],
            ((0,0), (0,1)), 'constant', constant_values=1.0)
        
        if self.is_extended:
            sample['keypoints_3d_extended'] = np.pad(
                shot['keypoints_extended'][:self.num_extended_keypoints],
                ((0,0), (0,1)), 'constant', constant_values=1.0)

        # build cuboid
        # base_point = sample['keypoints_3d'][6, :3]
        # sides = np.array([self.cuboid_side, self.cuboid_side, self.cuboid_side])
        # position = base_point - sides / 2
        # sample['cuboids'] = volumetric.Cuboid3D(position, sides)

        # save sample's index
        sample['indexes'] = idx
        sample['subject'] = subject
        sample['action'] = action
        #sample['subject'] = self.labels['subject_names']
        #sample['action'] = self.labels['action_names']

        if self.keypoints_3d_pred is not None:
            sample['pred_keypoints_3d'] = self.keypoints_3d_pred[idx]

        sample.default_factory = None
        
        return sample